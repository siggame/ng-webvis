// Generated by CoffeeScript 1.8.0
(function() {
  'use strict';

  /**
    * @ngdoc service
    * @name webvisApp.droids
    * @description
    * # droids
    * Service in the webvisApp.
   */
  var webvisApp,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  webvisApp = angular.module('webvisApp');

  webvisApp.provide.service('Droids', function(Renderer, Options) {
    var Droid;
    Droid = (function() {
      function Droid() {
        this.attackFunc = __bind(this.attackFunc, this);
        this.dropFunc = __bind(this.dropFunc, this);
        this.hackFunc = __bind(this.hackFunc, this);
        this.moveFunc = __bind(this.moveFunc, this);
        this.repairFunc = __bind(this.repairFunc, this);
        this.idleFunc = __bind(this.idleFunc, this);
        this.sprite = new Renderer.sprite;
        this.spawnTurn = -1;
        this.removeTurn = -1;
        this.variant = "";
        this.animations = {};
      }

      Droid.prototype.getAnimations = function() {
        return this.antimations;
      };

      Droid.prototype.idleFunc = function(e, droid) {
        return (function(_this) {
          return function(renderer, turn, progress) {
            var entity;
            entity = e[droid.id];
            if ((entity.spawnTurn - 1 <= turn && turn <= entity.removeTurn)) {
              entity.sprite = entity.variant + ".png";
              return renderer.drawSprite(entity.sprite);
            }
          };
        })(this);
      };

      Droid.prototype.repairFunc = function(e, repairAnim) {
        return (function(_this) {
          return function(renderer, turn, progress) {
            var l, p1, p2, source, target;
            source = e[repairAnim.sourceID];
            target = e[repairAnim.targetID];
            p1 = source.sprite.position;
            p2 = target.sprite.position;
            l = new Renderer.Line(p1.x, p1.y, p2.x, p2.y);
            l.color.setColor(0.0, 1.0, 0.0, 1.0);
            return renderer.drawLine(l);
          };
        })(this);
      };

      Droid.prototype.moveFunc = function(e, moves) {
        return (function(_this) {
          return function(renderer, turn, progress) {
            var diffX, diffY, entity, i, posX, posY, subt;
            entity = e[moves[0].actingID];
            i = parseInt(moves.length * progress);
            subt = (moves.length * progress) - i;
            diffX = moves[i].toX - moves[i].fromX;
            diffY = moves[i].toY - moves[i].fromY;
            posX = moves[i].fromX + diffX * subt;
            posY = moves[i].fromY + diffY * subt;
            entity.sp.position.x = posX;
            return entity.sp.position.y = posY;
          };
        })(this);
      };

      Droid.prototype.hackFunc = function(e, hackAnim) {
        return (function(_this) {
          return function(renderer, turn, progress) {
            var l, p1, p2, source, target;
            source = e[hackAnim.sourceID];
            target = e[hackAnim.targetID];
            p1 = source.sprite.position;
            p2 = target.sprite.position;
            l = new Renderer.Line(p1.x, p1.y, p2.x, p2.y);
            l.color.setColor(1.0, 0.0, 1.0, 1.0);
            return renderer.drawLine(l);
          };
        })(this);
      };

      Droid.prototype.dropFunc = function(e, dropAnim) {
        return (function(_this) {
          return function(renderer, turn, progress) {
            var entity, p;
            entity = e[dropAnim.sourceID];
            p = new Renderer.Point(entity.x - 3, entity.y - 20);
            entity.sprite.texture = "fireball.png";
            entity.sprite.position.x = p.x + (3 * progress);
            return entity.sprite.position.y = p.y + (20 * progress);
          };
        })(this);
      };

      Droid.prototype.attackFunc = function(e, attackAnim) {
        return (function(_this) {
          return function(renderer, turn, progress) {
            var l, p1, p2, source, target;
            source = e[attackAnim.actingID];
            target = e[attackAnim.sourceID];
            p1 = source.sprite.position;
            p2 = target.sprite.position;
            l = new Renderer.line(p1.x, p1.y, p2.x, p2.y);
            l.color.setColor(1.0, 0.0, 0.0, 1.0);
            return renderer.drawLine(l);
          };
        })(this);
      };

      return Droid;

    })();
    this.entities = {};
    this.droidsOptions = [["checkbox", "Test Checkbox", false], ["slider", "Test Slider", 0, 10, 2], ["textbox", "Test Textbox", ""], ["dropdown", "Test Dropdown", ["ex1", "ex2", "ex3", "ex4"], "ex2"]];
    Options.addPage("Droids", this.droidsOptions);
    this.maxTurn = 0;
    this.mapWidth = 0;
    this.mapHeight = 0;
    this.background = new Renderer.Sprite;
    this.gameLoaded = false;
    this.getName = function() {
      return "Droids";
    };
    this.getMaxTurn = function() {
      return this.maxTurn;
    };
    this.getMapWidth = function() {
      return this.mapWidth;
    };
    this.getMapHeight = function() {
      return this.mapHeight;
    };
    this.preDraw = function(renderer) {
      var i, l, _i, _j, _ref, _ref1, _results;
      renderer.drawSprite(this.background);
      for (i = _i = 1, _ref = this.mapHeight - 1; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        l = new Renderer.Line(0, i, this.mapWidth, i);
        l.color.setColor(0.0, 0.0, 0.0, 1.0);
        renderer.drawLine(l);
      }
      _results = [];
      for (i = _j = 1, _ref1 = this.mapWidth - 1; 1 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 1 <= _ref1 ? ++_j : --_j) {
        l = new Renderer.Line(i, 0, i, this.mapHeight);
        l.color.setColor(0.0, 0.0, 0.0, 1.0);
        _results.push(renderer.drawLine(l));
      }
      return _results;
    };
    this.getEntities = function() {
      return this.entities;
    };
    this.postDraw = function(renderer) {};
    this.isLoaded = function() {
      return this.gameLoaded;
    };
    this.loadGame = function(gamedata) {
      this.maxTurn = gamedata.turns.length;
      this.mapWidth = gamedata.turns[0].mapWidth;
      this.mapHeight = gamedata.turns[0].mapHeight;
      this.background.texture = "background";
      this.background.frame = 0;
      this.background.position.x = 0;
      this.background.position.y = 0;
      this.background.width = this.mapWidth;
      this.background.height = this.mapHeight;
      this.background.tiling = true;
      this.background.tileWidth = 24;
      this.background.tileHeight = 14;
      return this.gameLoaded = true;

      /*
       *create all entities
      for turn in gamedata.turns
          for id, droid of turn.Droid
              if !@entities[id]?
                  @entities[id] = new @Droid
      
                  a =  new PluginBase.Animation 0, @getMaxTurn(),
                      @Droid.idleFunc(@entities, droid)
      
                  @entities[id].animations.push a
      
              moves = []
              for anim in turn.animations[id]
                   * entity must have been initialized this turn or before
                   * to have an animation.
                  switch anim.type
                      when "add", "spawn"
                          @entities[id].spawnTurn = turn.turnNumber - 1
                      when "remove"
                          @entities[id].endTurn = turn.turnNumber
                      when "repair"
                          f = @Droid.repairFunc @entities, anim
      
                          a = new PluginBase.Animation turn.currentTurn,
                              turn.currentTurn + 1, f
      
                          @entities[id].animations.push a
      
                      when "move"
                          moves.push anim
      
                      when "hack"
                          f = @Droid.hackFunc @entities, anim
      
                          a = new PluginBase.Animation turn.currentTurn,
                              turn.currentTurn + 1, f
      
                          @entities[id].animations.push a
      
                      when "orbitalDrop"
                          f = @Droid.dropFunc @entities, anim
      
                          a = new PluginBase.Animation turn.currentTurn,
                              turn.currentTurn + 1, f
      
                          @entities[id].animations.push a
      
                      when "attack"
                          f = @Droid.attackFunc @entities, anim
      
                          a = new PluginBase.Animation turn.currentTurn,
                              turn.currentTurn + 1, f
      
                          @entities[id].animations.push a
      
      
              if moves.length > 0
                  f = @Droid.moveFunc @entities, moves
      
                  a = new PluginBase.Animation turn.currentTurn,
                      turn.currentTurn + 1, f
      
                  @entities[id].animations.push a
       */
    };
    this.getSexpScheme = function() {
      var scheme;
      scheme = {
        gameName: ["gameName"],
        Player: ["id", "playerName", "time", "spores"],
        Mappable: ["id", "x", "y"],
        Droid: ["id", "x", "y", "owner", "variant", "attacksLeft", "maxAttacks", "healthLeft", "maxHealth", "movementLeft", "maxMovement", "range", "attack", "armor", "maxArmor", "scrapWorth", "turnsToBeHacked", "hackedTurnsLeft", "hackets", "hacketsMax"],
        Tile: ["id", "x", "y", "owner", "turnsUntilAssembled", "variantToAssemble"],
        ModelVariant: ["id", "name", "variant", "cost", "maxAttacks", "maxHealth", "maxMovement", "range", "attack", "maxArmor", "scrapWorth", "turnsToBeHacked", "hacketsMax"],
        add: ["type", "sourceID"],
        remove: ["type", "sourceID"],
        spawn: ["type", "sourceID", "unitID"],
        repair: ["type", "actingID", "targetID"],
        move: ["type", "actingID", "fromX", "fromY", "toX", "toY"],
        hack: ["type", "actingID", "targetID"],
        orbitalDrop: ["type", "sourceID"],
        attack: ["type", "actingID", "targetID"],
        game: ["mapWidth", "mapHeight", "turnNumber", "maxDroids", "playerID", "gameNumber", "scrapRate", "maxScrap", "dropTime"]
      };
      return scheme;
    };
    return this;
  });

  console.log("service must be registered by now");

}).call(this);
